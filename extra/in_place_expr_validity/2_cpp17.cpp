#include <type_traits>
#include <vrm/pp.hpp>
#include <iostream>
#include <tuple>
#include <utility>
#include <experimental/tuple>

template <typename T>
struct type_w
{
    using type = T;
};

template <typename T>
constexpr type_w<T> type_c{};

template <typename ...Ts>
struct validity_checker {
    template <typename TF>
    static constexpr auto is_valid(TF)
    {
        return std::is_callable<std::decay_t<TF>(Ts...)>{};
    }
};

// The other `IS_VALID_EXPANDER_` should be generated by a script (or by an higher
// order preprocessor macro).

#define IS_VALID_EXPANDER_2(...) \
    ([](auto _0, auto _1) constexpr->decltype(__VA_ARGS__){})

#define IS_VALID_EXPANDER_1(...) \
    ([](auto _0) constexpr->decltype(__VA_ARGS__){})

#define IS_VALID(...) \
    validity_checker<__VA_ARGS__>::is_valid VRM_PP_CAT(IS_VALID_EXPANDER_, VRM_PP_ARGCOUNT(__VA_ARGS__))

struct Cat
{
    Cat() = delete;
    void meow() const
    {
        std::cout << "meow\n";
    }
};

struct Dog
{
    Dog() = delete;
    void bark() const
    {
        std::cout << "bark\n";
    }
};

template <typename T>
auto make_noise(const T& x)
{
    if constexpr(IS_VALID(T)(_0.meow()))
    {
        x.meow();
    }
    else if constexpr(IS_VALID(T)(_0.bark()))
    {
        x.bark();
    }
    else
    {
        struct cannot_meow_or_bark;
        cannot_meow_or_bark{};
    }
}

int main()
{
    make_noise(Cat{});
    make_noise(Dog{});
    // make_noise(int{});
}

